"""
This module implements a statistical equilibrium model for a
hydrogen sphere with five bound levels plus the continuum under
Case B conditions. It solves for the level populations given the
temperature T, total hydrogen number density n_Htot, and a fixed
ionization fraction x = n_e/n_Htot. The model includes radiative
downward transitions (with Einstein A‐coefficients) and electron‐
impact collisional excitation/de‐excitation. Recombination into
levels 2–5 is included with effective recombination fractions
(f2 = 0.60, f3 = 0.15, f4 = 0.15, f5 = 0.10) and a total Case B
coefficient alpha_B(T) = 2.59e-13 (T/1e4)^(-0.7) cm^3 s^-1
(Osterbrock & Ferland 2006; Storey & Hummer 1995).

The Hα emissivity (from the n=3→2 transition) is then computed
as

  ε_Hα = h ν_32 n_3 A_32 β(τ)

where β(τ) = (1 – exp(–τ))/τ is an escape probability that
parameterizes the effect of optical depth τ (log10(τ) spanning
–3 to +4).

Generated by ChatGPT o3-mini-high on March 20 2025.
"""

import numpy as np
import matplotlib.pyplot as plt

# Physical constants (cgs units)
h = 6.62607015e-27      # Planck constant [erg s]
c = 2.99792458e10       # Speed of light [cm/s]
k_B = 1.380649e-16      # Boltzmann constant [erg/K]
eV_to_erg = 1.60218e-12  # 1 eV in erg

# Recombination coefficient parameters
alphaB_1e4 = 2.59e-13   # cm^3 s^-1 at 1e4 K

# Effective recombination fractions for levels 2-5 (Case B)
f_recomb = {2: 0.60, 3: 0.15, 4: 0.15, 5: 0.10}

# Einstein A coefficients for allowed transitions (s^-1)
# Keys: (upper_level, lower_level)
A_dict = {
    (2, 1): 6.265e8,
    (3, 1): 1.672e8,
    (3, 2): 4.410e7,
    (4, 1): 8.200e7,
    (4, 2): 1.260e7,
    (4, 3): 2.100e7,
    (5, 1): 3.000e7,
    (5, 2): 4.000e6,
    (5, 3): 7.000e6,
    (5, 4): 1.000e7
}

# Collision strength (assumed constant for all transitions)
Omega_const = 0.3


def energy_level(n: int) -> float:
    """Compute the energy of hydrogen level n in erg.

    Args:
        n (int): Principal quantum number.

    Returns:
        float: Energy in erg (negative value).

    Generated by ChatGPT o3-mini-high on March 20 2025.
    """
    return -13.6 * eV_to_erg / (n ** 2)


def statistical_weight(n: int) -> float:
    """Return the statistical weight of level n.

    Args:
        n (int): Principal quantum number.

    Returns:
        float: Statistical weight g(n) = 2 n^2.

    Generated by ChatGPT o3-mini-high on March 20 2025.
    """
    return 2 * (n ** 2)


def collisional_rate(i: int, j: int, T: float, excitation: bool) -> float:
    """Compute the electron-impact collisional rate coefficient for
    the i→j transition.

    For excitation (i < j), the rate coefficient is given by

      q_ij = (8.63e-6 / (g_i sqrt(T))) * Omega *
             exp(-ΔE/(k_B T))  [cm^3 s^-1].

    For de-excitation (i > j), detailed balance gives

      q_ij = (8.63e-6 / (g_j sqrt(T))) * Omega  [cm^3 s^-1].

    Args:
        i (int): Lower level index for de-excitation or initial level for
                 excitation.
        j (int): Upper level index for excitation or final level for
                 de-excitation.
        T (float): Electron temperature in K.
        excitation (bool): True for excitation (i→j), False for de-
                           excitation (j→i).

    Returns:
        float: Collisional rate coefficient [cm^3 s^-1].

    Generated by ChatGPT o3-mini-high on March 20 2025.
    """
    if excitation:
        g_i = statistical_weight(i)
        delta_E = abs(energy_level(j) - energy_level(i))
        rate = (8.63e-6 / (g_i * np.sqrt(T)) *
                Omega_const *
                np.exp(-delta_E / (k_B * T)))
    else:
        g_j = statistical_weight(j)
        rate = 8.63e-6 * Omega_const / (g_j * np.sqrt(T))
    return rate


def get_A_coefficient(i: int, j: int) -> float:
    """Return the Einstein A coefficient for the i→j transition.

    Args:
        i (int): Upper level.
        j (int): Lower level.

    Returns:
        float: A coefficient in s^-1 if defined, else 0.

    Generated by ChatGPT o3-mini-high on March 20 2025.
    """
    return A_dict.get((i, j), 0.0) if i > j else 0.0


def rate(i: int, j: int, T: float, n_e: float) -> float:
    """Compute the total rate coefficient for the i→j transition,
    including radiative and collisional processes.

    For downward transitions (i > j), the rate is

      R_ij = A_ij + n_e * q_ij (de-excitation).

    For upward transitions (i < j), only collisional excitation
    contributes:

      R_ij = n_e * q_ij (excitation).

    Args:
        i (int): Initial level.
        j (int): Final level.
        T (float): Temperature in K.
        n_e (float): Electron density in cm^-3.

    Returns:
        float: Rate coefficient in s^-1.

    Generated by ChatGPT o3-mini-high on March 20 2025.
    """
    if i > j:
        A_ij = get_A_coefficient(i, j)
        q = collisional_rate(i, j, T, excitation=False)
        return A_ij + n_e * q
    elif i < j:
        q = collisional_rate(i, j, T, excitation=True)
        return n_e * q
    else:
        return 0.0


def alpha_B(T: float) -> float:
    """Compute the Case B total recombination coefficient for hydrogen.

    Uses the approximation

      α_B = 2.59e-13 (T/1e4)^(-0.7) [cm^3 s^-1].

    Args:
        T (float): Temperature in K.

    Returns:
        float: Case B recombination coefficient [cm^3 s^-1].

    Generated by ChatGPT o3-mini-high on March 20 2025.
    """
    return alphaB_1e4 * (T / 1e4) ** (-0.7)


def solve_level_populations(T: float, n_Htot: float, x: float) -> np.ndarray:
    """Solve for the level populations of the five bound levels of
    hydrogen in statistical equilibrium.

    The system is closed by enforcing the conservation

      n1 + n2 + n3 + n4 + n5 = n_Htot*(1 - x)

    and by using the net rate equations for levels 2-5. Recombination
    injection is included for levels 2-5 as (n_e*n_p)*f_i*α_B(T).

    Args:
        T (float): Temperature in K.
        n_Htot (float): Total hydrogen density (atoms + protons)
                        [cm^-3].
        x (float): Ionization fraction, n_e/n_Htot.

    Returns:
        np.ndarray: Array of level populations [n1, n2, n3, n4, n5]
                    in cm^-3.

    Generated by ChatGPT o3-mini-high on March 20 2025.
    """
    # Electron and proton density (pure hydrogen)
    n_e = n_Htot * x
    n_p = n_e
    # Total neutral hydrogen density
    N1_total = n_Htot * (1 - x)
    # Levels: 1,2,3,4,5; we will solve for n2,n3,n4,n5.
    # n1 is given by normalization: n1 = N1_total - (n2+n3+n4+n5)
    levels = [1, 2, 3, 4, 5]
    num_unknown = 4  # n2, n3, n4, n5

    # Build linear system A * X = b for unknown vector X = [n2, n3, n4, n5]
    A = np.zeros((num_unknown, num_unknown))
    b = np.zeros(num_unknown)

    # Precompute recombination injection for levels 2-5
    alpha_val = alpha_B(T)
    # For level 1, effective recomb is zero in Case B.
    recomb = {1: 0.0}
    for lev in levels[1:]:
        f_i = f_recomb.get(lev, 0.0)
        recomb[lev] = (n_e * n_p) * f_i * alpha_val

    # For each level i in 2,3,4,5, form the net rate equation.
    # We substitute n1 = N1_total - sum(X)
    for idx, lev in enumerate(levels[1:]):
        # Rate from level 1 to lev: r_1lev
        r_1lev = rate(1, lev, T, n_e)
        # Constant term from normalization:
        b[idx] = N1_total * r_1lev - recomb[lev]
        # Initialize coefficient for unknown corresponding to level lev.
        # Contribution from term with j=1: n1 = N1_total - sum(X)
        # gives an additional term: + r_1lev * X_j (for all j) when moved to LHS.
        # Now add contributions from j in {2,3,4,5}
        sum_term = 0.0
        for jdx, lev_j in enumerate(levels[1:]):
            if lev_j == lev:
                # For j == lev, contribution from self-term:
                # term: n_lev * [rate(lev,1) + sum_{k != lev} rate(lev,k)]
                r_term = rate(lev, 1, T, n_e)
                for kdx, lev_k in enumerate(levels[1:]):
                    if lev_k != lev:
                        r_term += rate(lev, lev_k, T, n_e)
                A[idx, jdx] = r_term + r_1lev
            else:
                # For j != lev, contribution: from n_j terms
                # term: + r_1lev * X_j - rate(lev_j, lev)*X_j.
                A[idx, jdx] = r_1lev - rate(lev_j, lev, T, n_e)
    # Solve the 4x4 linear system for n2, n3, n4, n5.
    X = np.linalg.solve(A, b)
    # Compute n1 from normalization.
    n1 = N1_total - np.sum(X)
    populations = np.empty(5)
    populations[0] = n1
    populations[1:] = X
    return populations


def beta_escape(tau: float) -> float:
    """Compute the escape probability β(τ) = (1 – exp(–τ))/τ.

    Args:
        tau (float): Optical depth.

    Returns:
        float: Escape probability.
        
    Generated by ChatGPT o3-mini-high on March 20 2025.
    """
    if tau == 0:
        return 1.0
    return (1.0 - np.exp(-tau)) / tau


def compute_Halpha_emissivity(T: float, n_Htot: float, x: float,
                              tau: float) -> float:
    """Compute the Hα emissivity (erg cm^-3 s^-1) from the n=3→2
    transition given the model parameters.

    The emissivity is given by

      ε_Hα = h ν_32 n_3 A_32 β(τ)

    where n_3 is the population of level 3, A_32 is the spontaneous
    decay rate for 3→2, and β(τ) is the escape probability.

    Args:
        T (float): Temperature in K.
        n_Htot (float): Total hydrogen density (cm^-3).
        x (float): Ionization fraction.
        tau (float): Optical depth for the Hα line.

    Returns:
        float: Hα emissivity in erg cm^-3 s^-1.

    Generated by ChatGPT o3-mini-high on March 20 2025.
    """
    # Solve for level populations: populations = [n1, n2, n3, n4, n5]
    pops = solve_level_populations(T, n_Htot, x)
    # n_3 corresponds to level 3; index 2 (0-indexed)
    n3 = pops[2]
    # Frequency for 3->2 transition: ΔE = E(2) - E(3)
    delta_E = abs(energy_level(2) - energy_level(3))
    nu_32 = delta_E / h
    A_32 = get_A_coefficient(3, 2)
    beta_val = beta_escape(tau)
    emissivity = h * nu_32 * n3 * A_32 * beta_val
    return emissivity


def explore_parameter_space():
    """Explore the Hα emissivity over a range of n_Htot and ionization
    fraction x for fixed T and optical depth τ. Generates a contour
    plot of log10(ε_Hα).

    Fixed parameters:
      T   = 1e4 K
      tau = 1.0

    Vary:
      n_Htot: 1e2 to 1e8 cm^-3 (log spaced)
      x: 0.001 to 0.5

    Generated by ChatGPT o3-mini-high on March 20 2025.
    """
    T = 2e4
    tau = 1.0
    nH_vals = np.logspace(2, 15, 100)
    x_vals = np.linspace(0.001, 0.5, 50)
    Emissivity = np.zeros((len(x_vals), len(nH_vals)))
    for i, x in enumerate(x_vals):
        for j, nH in enumerate(nH_vals):
            eps = compute_Halpha_emissivity(T, nH, x, tau)
            Emissivity[i, j] = eps
    # Create contour plot
    fig, ax = plt.subplots(figsize=(8, 6))
    cs = ax.contourf(nH_vals, x_vals, np.log10(Emissivity),
                     levels=20, cmap="viridis")
    cbar = fig.colorbar(cs, ax=ax)
    cbar.set_label(r'$\log_{10}(\epsilon_{H\alpha})\,[erg\,cm^{-3}\,s^{-1}]$')
    ax.set_xscale("log")
    ax.set_xlabel(r'$n_{\rm H,tot}\,[cm^{-3}]$')
    ax.set_ylabel('Ionization fraction, x')
    ax.set_title('Hα Emissivity Parameter Space\n'
                 r'($T=10^4$ K, $\tau=1.0$)')
    fig.tight_layout()
    fig.savefig("Halpha_emissivity_parameter_space.png")
    plt.close(fig)


if __name__ == '__main__':
    # Example: Compute emissivity for given parameters.
    T_example = 1e4         # K
    n_Htot_example = 1e6    # cm^-3
    x_example = 0.1         # ionization fraction
    tau_example = 1.0
    emissivity = compute_Halpha_emissivity(T_example,
                                           n_Htot_example,
                                           x_example,
                                           tau_example)
    print("Hα emissivity = {:.3e} erg cm^-3 s^-1".format(emissivity))
    # Explore parameter space and save figure.
    explore_parameter_space()
    print("Parameter space plot saved as "
          "'Halpha_emissivity_parameter_space.png'.")

