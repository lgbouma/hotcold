import numpy as np
import plotly.graph_objs as go
from dash import Dash, dcc, html, Input, Output
from astropy import constants as const
from astropy import units as u
from aesthetic.plot import set_style

set_style('science')


def compute_blob_vrange_at_phi(phi: float, delta_phi_deg: float,
                               Delta_r: u.Quantity,
                               torus_radius: u.Quantity,
                               n_r: int = 100,
                               n_theta: int = 100) -> tuple:
    """Compute the velocity range for a blob segment at a given phi.

    The blob is defined as a segment of an annulus with radial width Delta_r
    and azimuthal extent delta_phi_deg (in degrees). The torus is in rigid
    corotation with period 3.93 hours. The observed radial velocity at a point
    is given by v_obs = - (Omega * r) * sin(theta), where Omega = 2π/P.
    The function computes v_min, v_max and the overall v_range (v_max - v_min)
    by constructing a 2D grid in (r, theta).

    Generated by ChatGPT o3-mini-high on March 31 2025.

    Args:
        phi (float): Central azimuthal angle (radians) of the blob.
        delta_phi_deg (float): Azimuthal extent of the blob (degrees).
        Delta_r (u.Quantity): Radial width of the blob.
        torus_radius (u.Quantity): Central radius of the torus.
        n_r (int, optional): Number of radial grid points. Defaults to 100.
        n_theta (int, optional): Number of azimuthal grid points.
            Defaults to 100.

    Returns:
        tuple: (v_min, v_max, v_range, v_obs_flat) where velocities are in km/s.
    """
    delta_phi_rad = np.deg2rad(delta_phi_deg)
    # Radial limits of the blob segment.
    r_min = (torus_radius - Delta_r / 2).to(u.m)
    r_max = (torus_radius + Delta_r / 2).to(u.m)
    r_vals = np.linspace(r_min.value, r_max.value, n_r) * u.m
    theta_min = phi - delta_phi_rad / 2
    theta_max = phi + delta_phi_rad / 2
    theta_vals = np.linspace(theta_min, theta_max, n_theta)
    r_grid, theta_grid = np.meshgrid(r_vals, theta_vals, indexing='ij')
    period = 3.93 * u.hour
    Omega = 2 * np.pi / period
    v_grid = (Omega * r_grid).to(u.km / u.s)
    v_obs = -v_grid.value * np.sin(theta_grid)
    v_min = np.min(v_obs)
    v_max = np.max(v_obs)
    v_range = v_max - v_min
    return v_min, v_max, v_range, v_obs.flatten()


def compute_blob_vrange_over_phi(delta_phi_deg: float, Delta_r: u.Quantity,
                                 torus_radius: u.Quantity,
                                 num_phi: int = 360,
                                 n_r: int = 100,
                                 n_theta: int = 100) -> tuple:
    """Compute the velocity range over all central blob angles.

    For an annulus segment (blob) defined by its azimuthal extent delta_phi_deg
    and radial width Delta_r, this function computes v_min, v_max, and v_range
    as functions of the central blob angle phi spanning 0 to 2π, using rigid
    corotation.

    Generated by ChatGPT o3-mini-high on March 31 2025.

    Args:
        delta_phi_deg (float): Azimuthal extent of the blob in degrees.
        Delta_r (u.Quantity): Radial width of the blob.
        torus_radius (u.Quantity): Central radius of the torus.
        num_phi (int, optional): Number of phi values spanning 0 to 2π.
            Defaults to 360.
        n_r (int, optional): Number of radial grid points. Defaults to 100.
        n_theta (int, optional): Number of azimuthal grid points.
            Defaults to 100.

    Returns:
        tuple: (phi_vals, v_min_vals, v_max_vals, v_range_vals) where phi_vals
        are in radians and velocities in km/s.
    """
    phi_vals = np.linspace(0, 2 * np.pi, num_phi)
    v_min_vals = np.empty_like(phi_vals)
    v_max_vals = np.empty_like(phi_vals)
    v_range_vals = np.empty_like(phi_vals)
    for i, phi in enumerate(phi_vals):
        v_min, v_max, v_range, _ = compute_blob_vrange_at_phi(
            phi, delta_phi_deg, Delta_r, torus_radius, n_r, n_theta)
        v_min_vals[i] = v_min
        v_max_vals[i] = v_max
        v_range_vals[i] = v_range
    return phi_vals, v_min_vals, v_max_vals, v_range_vals


def create_annulus_polygon(r_center: float, Delta_r: float,
                           phi_center: float, delta_phi_rad: float,
                           num_points: int = 100) -> tuple:
    """Generate polygon coordinates for an annulus segment.

    The annulus segment is defined in polar coordinates by a central radius
    r_center, radial width Delta_r, central angle phi_center, and angular
    extent delta_phi_rad. The function returns Cartesian (x, y) coordinates
    normalized by the stellar radius.

    Generated by ChatGPT o3-mini-high on March 31 2025.

    Args:
        r_center (float): Central radius of the torus (in stellar radii).
        Delta_r (float): Radial width of the blob (in stellar radii).
        phi_center (float): Central blob angle (radians).
        delta_phi_rad (float): Angular extent (radians) of the blob.
        num_points (int, optional): Number of points along each boundary.
            Defaults to 100.

    Returns:
        tuple: (x_poly, y_poly) arrays for the polygon.
    """
    r_out = r_center + Delta_r / 2
    r_in = r_center - Delta_r / 2
    theta_min = phi_center - delta_phi_rad / 2
    theta_max = phi_center + delta_phi_rad / 2
    theta_outer = np.linspace(theta_min, theta_max, num_points)
    theta_inner = np.linspace(theta_max, theta_min, num_points)
    r_outer = np.full_like(theta_outer, r_out)
    r_inner = np.full_like(theta_inner, r_in)
    # Convert polar to Cartesian.
    x_outer = r_outer * np.cos(theta_outer)
    y_outer = r_outer * np.sin(theta_outer)
    x_inner = r_inner * np.cos(theta_inner)
    y_inner = r_inner * np.sin(theta_inner)
    # Concatenate to form a closed polygon.
    x_poly = np.concatenate([x_outer, x_inner])
    y_poly = np.concatenate([y_outer, y_inner])
    return x_poly, y_poly


# Create the Dash app.
app = Dash(__name__)
app.layout = html.Div([
    html.Div([
        dcc.Graph(id='polar-plot'),
    ], style={'width': '48%', 'display': 'inline-block'}),
    html.Div([
        dcc.Graph(id='velocity-plot'),
    ], style={'width': '48%', 'display': 'inline-block', 'float': 'right'}),
    html.Div([
        html.Label("Torus Radius (in stellar radii, r_star)"),
        dcc.Slider(id='torus-radius-slider', min=1, max=5, step=0.1,
                   value=2.4, marks={i: str(i) for i in range(1, 6)}),
        html.Label("Azimuthal Extent (Δφ in degrees)"),
        dcc.Slider(id='delta-phi-slider', min=0, max=360, step=1,
                   value=10, marks={0: '0', 180: '180', 360: '360'}),
        html.Label("Radial Width (Δr in stellar radii)"),
        dcc.Slider(id='delta-r-slider', min=0.01, max=1, step=0.01,
                   value=0.1, marks={0.01: "0.01", 0.5: "0.5", 1: "1"}),
        html.Label("Central Blob Angle (φ in degrees)"),
        dcc.Slider(id='phi-center-slider', min=0, max=360, step=1,
                   value=0, marks={0: '0', 180: '180', 360: '360'})
    ], style={'width': '90%', 'padding': '20px', 'margin': 'auto'})
])


@app.callback(
    [Output('polar-plot', 'figure'),
     Output('velocity-plot', 'figure')],
    [Input('torus-radius-slider', 'value'),
     Input('delta-phi-slider', 'value'),
     Input('delta-r-slider', 'value'),
     Input('phi-center-slider', 'value')]
)
def update_plots(torus_radius_val: float, delta_phi_deg: float,
                 delta_r_val: float, phi_center_deg: float) -> tuple:
    """Update both the polar and velocity plots based on slider inputs.

    The torus radius and radial width are converted from stellar radii to
    physical units using the star's radius (0.42 R_sun). The polar plot shows
    the annulus segment and a radial line at the central blob angle. The
    velocity plot shows the computed v_min, v_max, and v_range as functions of
    central blob angle, with a vertical line marking the current φ.

    Args:
        torus_radius_val (float): Torus radius in stellar radii.
        delta_phi_deg (float): Azimuthal extent in degrees.
        delta_r_val (float): Radial width in stellar radii.
        phi_center_deg (float): Central blob angle in degrees.

    Returns:
        tuple: (polar_fig, velocity_fig) as Plotly figure dictionaries.
    """
    # Define the star's physical radius.
    r_star = 0.42 * const.R_sun
    # Convert slider values to physical quantities.
    torus_radius_phys = torus_radius_val * r_star
    Delta_r_phys = delta_r_val * r_star
    # Convert central blob angle to radians.
    phi_center_rad = np.deg2rad(phi_center_deg)
    delta_phi_rad = np.deg2rad(delta_phi_deg)

    # PANEL 1: Create the top-down polar (Cartesian) plot.
    # In normalized units (in units of r_star).
    # Blob annulus polygon.
    x_poly, y_poly = create_annulus_polygon(
        r_center=torus_radius_val, Delta_r=delta_r_val,
        phi_center=phi_center_rad, delta_phi_rad=delta_phi_rad, num_points=200)
    polar_fig = go.Figure()
    polar_fig.add_trace(go.Scatter(
        x=x_poly, y=y_poly, mode='lines',
        fill='toself', name='Annulus Segment',
        line=dict(color='royalblue')
    ))
    # Add the star as a circle of radius 1.
    polar_fig.update_layout(
        shapes=[dict(
            type="circle",
            xref="x", yref="y",
            x0=-1, y0=-1, x1=1, y1=1,
            line=dict(color="black")
        )],
        xaxis=dict(scaleanchor="y", title="x (r_star)"),
        yaxis=dict(title="y (r_star)"),
        title="Top-Down View of Annulus Segment"
    )
    # Add a radial line at the central blob angle (from inner to outer edge).
    r_in_norm = torus_radius_val - delta_r_val / 2
    r_out_norm = torus_radius_val + delta_r_val / 2
    x_line = [r_in_norm * np.cos(phi_center_rad),
              r_out_norm * np.cos(phi_center_rad)]
    y_line = [r_in_norm * np.sin(phi_center_rad),
              r_out_norm * np.sin(phi_center_rad)]
    polar_fig.add_trace(go.Scatter(
        x=x_line, y=y_line, mode='lines', name='Central Angle',
        line=dict(color='red', dash='dash')
    ))

    # PANEL 2: Compute the radial velocity ranges over phi.
    phi_vals, v_min_vals, v_max_vals, v_range_vals = (
        compute_blob_vrange_over_phi(delta_phi_deg, Delta_r_phys,
                                     torus_radius_phys,
                                     num_phi=360, n_r=100, n_theta=100)
    )
    # Convert phi values to degrees for plotting.
    phi_deg = np.rad2deg(phi_vals)
    velocity_fig = go.Figure()
    velocity_fig.add_trace(go.Scatter(
        x=phi_deg, y=v_min_vals, mode='lines', name='v_min (km/s)',
        line=dict(color='blue')
    ))
    velocity_fig.add_trace(go.Scatter(
        x=phi_deg, y=v_max_vals, mode='lines', name='v_max (km/s)',
        line=dict(color='green')
    ))
    velocity_fig.add_trace(go.Scatter(
        x=phi_deg, y=v_range_vals, mode='lines', name='v_range (km/s)',
        line=dict(color='purple', dash='dash')
    ))
    # Add a vertical line at the current central blob angle.
    velocity_fig.add_shape(
        type="line",
        x0=phi_center_deg, x1=phi_center_deg,
        y0=min(v_min_vals), y1=max(v_max_vals),
        line=dict(color="red", dash="dash"),
    )
    velocity_fig.update_layout(
        xaxis=dict(title="Central Blob Angle (deg)"),
        yaxis=dict(title="Radial Velocity (km/s)"),
        title="Radial Velocity vs. Central Blob Angle"
    )
    return polar_fig, velocity_fig


if __name__ == '__main__':
    app.run(debug=True)
